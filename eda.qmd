# EDA {#sec-EDA}

```{r}
#| echo: false
source("_common.R")
source("_functions.R")
source("_load.R")
```

```{r}
#| echo: false
datos_split <- board_folder(path = "split_data")
```


```{r}
#| echo: false
ctl_split <- pin_read(board = datos_split, name = "split_datos")
ctl_train <- training(ctl_split)
```

## Estructura

El proceso de preparación y limpieza dió como resultado un único set de datos,
el cual consta de `r nrow(ctl_train)` filas y `r ncol(ctl_train)` columnas.

```{r}
ctl_train |> glimpse(width = 71)
```

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-ctl
#| tbl-cap: "ctl"
ctl_train |> 
 slice_head(n = 5) |> 
 gt() |> 
 tab_header(
    title = md("**Muestra Aleatoria - CTL**"),
    subtitle = md("Tabla principal")
  ) |> 
 gt_theme_538() |> 
 fmt_number(columns = cll_prctg:last_col(), decimals = 2) |> 
 cols_align_decimal() |> 
 cols_align(align = "center", columns = where(~ is.numeric(.x))) |> 
 tab_footnote(
  footnote = md("Cada usuario tiene el top 5 celdas a las que más se conecta"),
  locations = cells_body(columns = bts_sh_nm, rows = 1)) 
```

```{r}
#| code-fold: true
#| fig-align: center
#| code-summary: "Código"
#| label: fig-resumen
#| fig-width: 9
#| fig-cap: Se puede apreciar que la gran mayoría de las columnas están completas. Un 80% son *features* de tipo continuo y el restante son de tipo categórico.  Se requiere explorar los valores faltantes con mayor detalle.
plot_intro(
 ctl_train,ggtheme = yunkel,
 title = "Resumen Descriptivo",
 geom_label_args = list(label.size = 0.8, size = 7),
 theme_config = list(
 axis.text = element_text(size = 40)))
```

## Medidas repetidas {#sec-mr}

```{r}
#| code-fold: true
#| code-summary: "Código"
#| label: tbl-repetidos
#| tbl-cap: "Valores repetidos"
#| column: page
ctl_train |>
 get_dupes(msisdn_dd) |> 
 head(5) |> 
 select(
  fct_srvy_dt, msisdn_dd, srvy_id, bts_sh_nm) |> 
 gt() |> 
 tab_header(
  title = md("**Datos de Perfil**"),
    subtitle = md("Medidas repetidas")
  ) |> 
 gt_theme_538()
```

En la tabla @tbl-repetidos vemos que el identificador único (número de 
celular del usuario) se repite, debido a que contamos con datos de
[perfil](https://bit.ly/3PjtasC)


## Valores faltantes


```{r}
#| fig-align: center
#| label: fig-faltantes
#| fig-cap: La mayor cantidad de valores perdidos se encuentra en la columna `thp_required_lte`. Dependiendo de la distribución de los mismos será posible aplicar técnicas de imputación en la fase de preprocesamiento
#| code-fold: true
#| code-summary: "Código"
#| fig-width: 8
plot_missing(ctl_train, missing_only = TRUE,
 ggtheme = yunkel,
 title = "Valores Faltantes",
 geom_label_args = list(label.size = 0.8, size = 8),
 theme_config = list(
  axis.text = element_text(size = 40)))
```

## Resumen estadístico

```{r}
# crear set de datos solo con variables numéricas
ctl_n <- ctl_train |>
 select(where(is.numeric), -c(msisdn_dd, srvy_id))
```

</br>

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-resumen
#| cap-location: bottom
#| tbl-cap: Resumen estadístico
ctl_n |> 
 resumir() |> 
 gt() |> 
 # tab_header(
 #  title = md("**Resumen Estadístico**"),
 #    subtitle = md("para *features* Numéricos")
 # ) |> 
 gt_theme_538() |> 
 cols_align(align = "center", columns = where(~ is.numeric(.x))) |> 
 fmt_number(columns = where(is.numeric), decimals = 2)
```

En @tbl-resumen se observa que hay valores atípicos en algunas
observaciones.  Los valores mínimos con valor cero para algunas variables
ameritan atención.  

## Análisis univariado

### Variable dependiente

Uno de los primeros pasos del proceso de análisis exploratorios cuando el
propósito final es predecir una respuesta es crear visualizaciones que
ayuden a dilucidar el conocimiento de la respuesta y luego descubrir
relaciones entre los predictores y la respuesta [@kuhn_feature_2020].

```{r}
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-depe
#| fig-cap: Distribución de la variable dependiente
ctl_train |> 
 barra(diag) +
 theme(legend.position = "none") +
 labs(title = "Clasificación variable politómica")
```

Tal como se muestra en la @fig-depe se observa un desbalance en la variable
respuesta.  Este desequilibrio puede ocasionar que el modelo se sesgue hacia
las clases más frecuentes, como "CAPACIDAD" y "PROMOTOR", lo que podría llevar
a un rendimiento deficiente en la clasificación de otras clases.  La aplicación
de técnicas de remuestreo para balancear las clases será clave en la fase de
preprocesamiento.

### Variables numéricas {#sec-distribuiciones}

Analizar la distribución de cada predictor nos puede orientar sobre si
necesitamos hacer ingeniería de características mediante transformaciones antes
del análisis. [@kuhn_feature_2020]

```{r}
dob <- ctl_n |> 
 drop_na()
```

```{r}
# parámetros para graficar distribuciones
pal <- allcolors[1:ncol(dob)]
ndv <- names(dob)
nar <- str_to_title(ndv)
```

```{r}
# crear distribuciones
dist_predictores <- list(ndv, pal, nar) |>
  pmap(~ estimar_densidad(df = dob, d = ..1, color = ..2, titulo = ..1))
```

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| fig-height: 6
#| fig-width: 8
dist_predictores[1:2] |>
 reduce(.f = `+`) +
 plot_layout(ncol = 2) +
 plot_annotation(title    = "Distribución predictores numéricos")
```

- **thp_required_lte:** Se observa en la distribución es plausible.  Se espera
que la mayoría de los usuarios se mantengan un mayor porcentaje de tiempo con
el *throughput* requerido. Sin embargo, el sesgo negativo de esta distribución
podría tener un impacto en el rendimiento del modelo. 

- **cll_prctg:** El sesgo positivo es consistente con una distribución
exponencial, la cual es comúnmente utilizada para modelar el tiempo entre
eventos en un proceso de Poisson, como en este caso.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[3:4] |>
 reduce(.f = `+`)
```

- **rate_prb_dl:** Sabemos que una alta utilización del PRBs podría indicar
una alta demanda de recursos y potencialmente llevar a una degradación del
rendimiento de la red. El comportamiento bimodal podría ser un indicio de que
hay partes de la red que tienen una utilización de recursos muy baja, es decir,
debido a sub-utilización.  Sería beneficioso analizar en que partes de la red
se tiene este rango (0.00 - 0.05) de utilización como parte del análisis de QA.

- **rrc_success_rate:** En la distribución vemos que la gran mayoría de usuarios
presentan una alta tasa de éxito en cuanto a las conexiones RRC (Radio
Resource Control) entre su dispositivo móvil y la red. 


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[5:6] |>
 reduce(.f = `+`)
```

- **erab_success_rate:** Mide la tasa de éxito en la configuración,
modificación y liberación de los portadores de servicio de acceso
radioeléctrico (E-RAB) en una red LTE. Básicamente, muestra qué tan bien la red
está asignando recursos a los usuarios para establecer conexiones de datos y
voz. La distribución es la esperada con un sesgo positivo muy pronunciado, lo
cual es un indicador de que la mayor parte del tiempo este indicador se
encuentra en un rango saludable.

- **l_ul_interferance_avg:** Representa la interferencia promedio en el enlace
ascendente (UL) de una celda LTE. Se mide en decibelios-milivatios (dBm) y
sirve para evaluar el nivel de ruido o interferencia que podría estar afectando
la calidad del enlace ascendente. Altos niveles de interferencia pueden llevar
a una degradación de la calidad de la llamada, reducir el rendimiento del
enlace de datos y afectar negativamente la experiencia general del usuario. Un
número menor (más negativo) generalmente indica menos interferencia, lo cual es
positivo para el rendimiento de la red. Se aprecia un comportamiento bimodal lo
que podría ser un indicio de celdas problemas muy serios o que están
desconfiguradas. Se debe investigar si es un error en los datos o si son casos
particulares.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[7:8] |>
 reduce(.f = `+`)
```

- **throughput_dl:** Mide la velocidad de descarga por Unidad de Equipo de 
Usuario en una red celular, generalmente en Mbps. Según la gráfica, el downlink
se ubica en su mayoría arriba de los 25Mbps, lo cual es esperado.  Lo que es
necesario analizar es el throughput_dl menor a 2.7 Mbps.

- **throughput_ul:** Mide la velocidad de transmisión de datos del dispositivo
móvil a la estación base, generalmente también en Mbps. Es normal observar
valores más bajos en el *uplink* que en el *downlink*. El sesgo positivo
también es adecuado.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[9:10] |>
 reduce(.f = `+`)
```

- **corrected_cqi:** Evalúa la calidad de una celda en una red móvil. Este
índice toma en cuenta varios factores como la potencia de la señal, el nivel de
interferencia y otros parámetros clave para dar un indicador comprensivo de
cómo está funcionando una celda en particular. Aunque los detalles pueden
variar según el fabricante y la implementación, en esencia, mide qué tan bien
una celda puede manejar el tráfico y proporcionar un servicio de alta calidad a
los usuarios. Como política, el departamento de QA definió un umbral crítico de
7, significando que todo lo que esté por debajo de dicho umbral es malo. Debido
a la naturaleza discreta de la distribución de estos valores, observamos que la
superposición de densidad aparenta multimodalidad, sin embargo,
no es así.  Se debe investigar las observaciones que tienen un valor de cero en
esta métrica, ya que son atípicos importantes.

- **ra_ta_ue_index1:** Es una métrica que, en función de distintos índices,
indica tanto la distancia aproximada entre la estación base y el dispositivo
móvil, como la cantidad de conexiones realizadas a esas distancias específicas.
Se utiliza para evaluar y optimizar la cobertura y la capacidad de la red. El
sesgo positivo en este tipo de métrica es esperado en vista de que depende de
la cantidad de muestras de dicha celda.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[11:12] |>
 reduce(.f = `+`)
```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[13:14] |>
 reduce(.f = `+`)
```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[15:16] |>
 reduce(.f = `+`)
```

- **ra_ta_ue_index2-7:** Al igual que con ra_ta_ue_index1, el timing advanced
del 2 al 7 representan la cantidad de conexiones realizadas a una determinada
distancia. Lo importante es ver que existen más muestras en los
índices más próximos a 1 y deberían existir pocas conexiones en los índices más
altos. Muchas conexiones en índices más altos indicaría que muchos usuarios se
están conectando a las celdas desde lugares muy lejanos o hay otros problemas
como obstáculos u optimización.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[17:18] |>
 reduce(.f = `+`)
```

- **ra_ta_ue_total:** Cantidad total de conexiones de datos o llamadas. Pueden
ser del mismo terminal. Pocas celdas tendran muestras muy elevadas.

- **volte_erlang:** Mide el volumen de tráfico VoLTE (Voice over LTE) en la
red. Se expresa en "erlangs", que es una unidad de medida de carga de tráfico
telefónico. Si cualquier otra banda supera 1/3 del tráfico VoLTE de la banda
850, se considera una situación crítica. Es necesario tener visibilidad del
tráfico VoLTE en todas las bandas utilizadas para VoLTE, no solo la 850.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[19:20] |>
 reduce(.f = `+`)
```

- **modulation_64qam_ratio:** Se define como el porcentaje de tiempo en que la
transferencia de datos usa 64QAM, que es una modulación de alta eficiencia.
Esta modulación permite transmitir más bits de información y usa menos bits
para la corrección de errores, lo que la hace más eficiente pero también más
susceptible a problemas de calidad de señal. Como se aprecia en el histograma,
hay un comportamiento bimodal que puede indicar que en ciertas celadas o bien
ubicaciones geográficas, hay pocos usuarios utilizando este tipo de modulación
de mayor capacidad.  Dejando de lado el valor atípico, se observa que la
distribución es bastante normal.

- **modulation_16qam_ratio:** Representa el porcentaje de tiempo que la red
está utilizando la modulación 16-Quadrature Amplitude Modulation (16QAM) para
la transferencia de datos. Esta modulación es intermedia en términos de
eficiencia y robustez, permitiendo un balance entre la cantidad de datos
transmitidos y la corrección de errores. Es menos eficiente que 64QAM pero más
robusta contra errores y condiciones de señal no ideales.  La distribución
parece normal y se observa, al igual que con 64QAM, un comportamiento bimodal
que podría ser indicativo de que hay presente otra población en este tipo de
modulación.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[21:22] |>
 reduce(.f = `+`)
```

- **modulation_qpsk_ratio:** Representa el porcentaje de tiempo en que la red
utiliza la modulación Quadrature Phase Shift Keying (QPSK) para la
transferencia de datos. QPSK es una forma de modulación que es más robusta en
ambientes con condiciones de señal no ideales, como ruido o interferencias. Sin
embargo, es menos eficiente para la transmisión de datos en comparación con
16QAM o 64QAM. A diferencia de los otros dos tipos de modulación, la
distribución de esta modulación es positiva, similar a una distribución
exponencial.  Podría hacer sentido si el objetivo del departamento de QA es
utilizar este tipo de modulación como último recurso en caso de que no se
tengan las condiciones adecuadas en términos de interferencia o cobertura.

- **time_cl:** Es una medida fabricada que toma en cuenta la utilización de
PRBs, el CQI, y la velocidad target de la celda, para determinar el grado de
cumplimiento de esa velocidad. Porcentaje de tiempo en buen cell_load, va tanto
3G como LTE. El sesgo negativo es correcto en vista de que se espera que la
mayor parte de las conexiones se encuentren con un buen `cell_load`.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[23:24] |>
 reduce(.f = `+`)
```

- **time_lte:** Porcentaje de tiempo que permanece conectado a la tecnología
LTE. Entre más tiempo permanece un usuario conectado a la red LTE, podemos
decir que es bueno.  Abajo del 80% podría indicar que las celdas tienen un alto
cell_load lo que indicaría que el terminal hizo el cambio automático a 3G.
Navegar en 3G por lo general se traduce en una experiencia más pobre.  El sesgo
de la distribución es plausible.

- **avlblty:** Porcentaje de tiempo de navegación sin falla. Esto aplica por
usuario y representa un medida de que tanto un usuario navegó la cantidad de Mb
esperados con base a su mediana de consumo. La distribución con sesgo negativo
es consistente con la definición de la métrica.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[25:26] |>
 reduce(.f = `+`)
```

-**avlblty_tckt_2hrs y unvlbty_ttl_hrs_prop:** Son métricas complementarias a
la de disponibilidad y representan partes de la disponibilidad. Su sesgo es
opuesto.


Como se señaló en la sección @sec-mr, los datos de perfil demandan un
preprocesamiento especializado. Los modelos seleccionados deben ser robustos
ante este tipo de datos y la presencia de valores atípicos. Por esta razón, es
recomendable considerar modelos basados en árboles, que son inherentemente más
tolerantes a estas características. Además, se explorarán diversas
transformaciones de las variables para evaluar y comparar su impacto en el
rendimiento del modelo.


### Variables categóricas

```{r}
ctl_c <- ctl_train |>
 select(where(is.character), -diag) 
```


```{r}
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-cardinalidad
#| fig-cap: Análisis de cardinalidad de variables categóricas
ctl_c |>
 inspect_cat() |> 
 show_plot(high_cardinality = 4, col_palette = 1)
```

```{r}
#| dev: "png"
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-var-categoricas
#| fig-cap: Conteo de variables categóricas
plot_bar(
 data    = ctl_c, 
 ggtheme = yunkel, 
 theme_config = list(strip.text = element_text(size = 22)))
```

```{r}
#| dev: "png"
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-celdas-recurrentes
#| fig-cap: Top de celdas recurrentes por usuarios
ctl_c |> 
 select(bts_sh_nm) |> 
 mutate(celda = fct_lump(bts_sh_nm, n = 10, other_level = "OTRAS")) |> 
 count(celda, sort = TRUE) |> 
 filter(celda != "OTRAS") |> 
 mutate(celda = fct_reorder(celda, n, .desc = FALSE)) |> 
 ggplot(aes(y = celda, x = n)) +
 geom_col() +
 labs(title = "Top celdas más concurridas")
```

## Análisis bivariado

### Dependiente vs numéricas

#### Gráficos de confianza

Debido al desbalance de clases presente en la variable respuesta, será
necesario reflejar claramente el grado de incertidumbre que esto ocasiona.  Si
una clase tiene más observaciones que otra entonces la comparación no sería
justa y la variabilidad podría tener que ver con esto más que con la
variabilidad inherente que intentamos capturar. Para hacer esto, primero
recordemos que una estimación de intervalo describe un rango de valores dentro
del cual es posible que esté un parámetro de la población y un intervalo de
confianza es la probabilidad que asociamos con una estimación de intervalo
[@levin_statistics_1998].

En este sentido, los gráficos de confianza son esenciales para entender no solo
la relación de la variable categórica `diag` con las métricas numéricas, sino
también para capturar el grado de incertidumbre asociado con estas
métricas. Estos gráficos nos permiten ir más allá de las simples medias y
observar cómo la variabilidad en los datos afecta nuestras conclusiones.

Los gráficos de confianza nos permiten ver cómo cada métrica, se relaciona
directamente con las categorías de `diag`. Por ejemplo, si observamos que los
intervalos de confianza para `thp_required_lte` son significativamente bajos en
la categoría "CAPACIDAD", podemos inferir con cierto grado de confianza que un
`thp_required_lte` bajo generalmente indica un problema de capacidad.

El intervalo da una idea de dónde podrían caer las verdaderas medias de
`thp_required_lte` para cada categoría si tuvieras acceso a toda la población,
en lugar de solo una muestra.

::: {.callout-note}
#### ¿Por qué no solo usar boxplots?
Aunque los boxplots ofrecen una visión más completa de la distribución de los
datos, no proporcionan el mismo nivel de detalle sobre la incertidumbre en torno
a la media que los gráficos de confianza. Usar ambos proporciona una visión más
completa de los datos. Los gráficos de confianza dan detalles sobre la media y
su incertidumbre, mientras que los boxplots muestran la distribución completa.
:::

```{r}
# Función para calcular la media y el intervalo de confianza
mean_ci <- function(df, metrica, conf.level = 0.95) {
 x  <- df[[metrica]][!is.na(df[[metrica]])]
 n  <- length(x)
 m  <- mean(x)
 se <- sd(x) / sqrt(n)
 ci <- t.test(x)$conf.int
 data.frame(media = m, lower = ci[1], upper = ci[2])
}
```

```{r}
# Función para crear un dataframe con los intervalos por cada métrica
calcular_ci <- function(kpi) {
 ctl_train |> 
 group_by(diag) %>%
 do(mean_ci(., kpi)) %>%
 ungroup() %>%
 arrange(media)
}
```

```{r}
# Guardar las métricas que vamos a comparar
network_metrics <- names(ctl_n)
```

```{r}
# Crear lista de dataframes con intervalos de confianza
lista_ci <- network_metrics |> 
 map(~ calcular_ci(kpi = .x)) |> 
 set_names(network_metrics)
```

```{r}
# Crear una lista con las gráficas de cada métrica
analisis_bivariado <- lista_ci |> 
 map2(.y = network_metrics, ~ ggplot(.x, aes(x = diag, y = media)) +
 geom_point() +
 geom_errorbar(aes(ymin = lower, ymax = upper), width = .1) +
 theme(axis.text = element_text(size = 8)) +
 xlab("Diagnóstico") +
 labs(title = .y) +
 drako)
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-thp-required-lte
#| fig-cap: Porcentaje de tiempo que mantiene el throughput requerido en LTE
walk(analisis_bivariado[1], ~ print(.x))
```

Tal como se ilustra en la figura @fig-thp-required-lte el intervalo de confianza
para la categoría "CAPACIDAD" va de aproximadamente 0.85 a 0.861.  Esto
significa que, con un 95% de confianza, se puede decir que la la verdadera
media de `thp_required_lte` se encuentra en este rango. 

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-cll-prctg
#| fig-cap: Porcentaje de tiempo que el usuario estuvo conectado a la celda.
walk(analisis_bivariado[2], ~ print(.x))
```

Los resultados observados en la @fig-cll-prctg son consistentes con las
expectativas.  Vemos que la categoría "PROMOTOR" muestra un alto porcentaje de
tiempo de conexión a la red, lo cual es congruente con la naturaleza de esta
categoría.  Los intervalos altos pueden deberse a una alta variabilidad en los
datos.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-rate-prb-dl
#| fig-cap: Porcentaje de bloques físicos utilizados para transmitir datos desde la RBS hacia los terminales. Una alta tasa de utilización de PRB podría generar problemas de capacidad.
walk(analisis_bivariado[3], ~ print(.x))
```

Esta métrica es utilizada principalmente por el equipo CTL para determinar
problemas de capacidad en la red LTE.  Vemos en la @fig-rate-prb-dl que hay una
diferencia grande entre esta medición y el resto de categorías, es decir,
niveles altos de `rate-prb-dl` se asocian con problemas de capacidad en la
celda.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-rrc-success-rate
#| fig-cap: Eficiencia en el establecimiento de una conexión RRC
walk(analisis_bivariado[4], ~ print(.x))
```

Sabemos que una métrica puede impactar múltiples categorías. El equipo CTL
utiliza esta métrica principalmente para determinar problemas de optimización,
sin embargo, también puede asociarse a problemas de cobertura. La explicación
es que si la tasa de éxito de RRC es baja, esto podría deberse a áreas con
señal débil o a problemas con la infraestructura de la red.  

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-erab-success-rate
#| fig-cap: Tasa de éxito en la configuración, liberación y modficación de portadoras de servicio de accesso radioeléctrico (E-RAB)
walk(analisis_bivariado[5], ~ print(.x))
```

Al igual que con la métrica anterior, esta métrica puede generar varias
etiquetas si se combina con otras.  De manera aislada y directa parece estar
más relacionada a problemas con cobertura.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-interference
#| fig-cap: Interferencia promedio del enlace ascendente (uplink) de la celda
walk(analisis_bivariado[6], ~ print(.x))
```

En la @fig-interference se aprecia que valores mayores de interferencia podrían
ocasionar problemas de cobertura.  Esta métrica en particular puede
interactuar con muchas otras métricas para determinar otro tipos de problemas
en la red como por ejemplo optimización.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-dl
#| fig-cap: Velocidad de descarga por Unidad de Equipo de Usuario en una red celular, generalmente en Mbps. 
walk(analisis_bivariado[7], ~ print(.x))
```

CTL describe esta métrica principalmente en términos de capacidad, sin embargo,
se observa que la estimación puntual de la media para cobertura se encuentra
muy cercana.  En este caso, amerita evaluar si esta diferencia es significativa.

```{r, anova-una-via}
#| echo: false
#| cache: true
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-dl-anova
#| fig-cap: ANOVA entre-sujetos
bx(.df = ctl_train, .x = diag, .y = thoughput_dl)
```

En la parte superior de la @fig-throuput-dl-anova vemos el resultado de la
prueba estadística de Fisher.  El p-valor indica que si hay diferencias
significativas con un tamaño de efecto de $\widehat{\omega_{p}^{2}} = 0.09$.
Este tamaño de efecto se puede medir como 9% lo cual es bajo. Se ve en las
comparaciones por pares que capacidad y cobertura presentan diferencias
estadísticamente significativas.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-ul
#| fig-cap: Velocidad de transmisión de datos del dispositivo móvil a la estación base, generalmente también en Mbps.
walk(analisis_bivariado[8], ~ print(.x))
```

El equipo CTL no utiliza esta métrica como parte de su proceso de etiquetado,
sin embargo, la hemos colocado ya que puede ser útil en algunos contextos.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-corrected-cqi
#| fig-cap: Índice de calidad general de la celda
walk(analisis_bivariado[9], ~ print(.x))
```

La @fig-corrected-cqi muestra los diferentes índices para cada una de las
categorías. Todo lo que esté por arriba de 7 se considera bueno.  Aunque el 
equipo CTL indica que esta métrica tiene más utilidad para determinar
problemas de optimización, lo que destaca a simple vista es que valores bajos
de esta métrica se asocian más con problemas de cobertura.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-index-1
#| fig-cap: Cantidad de conexiones realizadas a distancias específicas dadas por el índice.
walk(analisis_bivariado[10:17], ~ print(.x))
```

Lo observado es consistente con lo esperado.  En el caso del índice 1, un
porcentaje bajo de conexiones en este índice podría indicar que el resto de
muestras se están obteniendo de índices más lejanos.  Se observa que a partir
del índice 4 el porcentaje empieza a ser diferente entre capacidad y
cobertura. En el índice 5 cobertura y capacidad tienen un porcentaje cercano,
pero siempre cobertura es menor, hasta que finalmente en índice 6 ciertas
conexiones se pueden etiquetar tanto como problemas de capacidad como de
cobertura.

#### Variabilidad y rango

Debido a que 

```{r}
#| eval: false
ctl_normalized <- ctl_train |>
 select(where(is.numeric), 
  -c(msisdn_dd, srvy_id), diag) |> 
 recipe(diag ~ ., data = _) |> 
 step_best_normalize(all_predictors(), -all_nominal())  |> 
 ver()
```


```{r}
#| eval: false
#| echo: false
write_fst(ctl_normalized, path = "data/ctl_normalized.fst", compress = 0)
```

```{r}
#| echo: false
ctl_normalized <- read_fst("data/ctl_normalized.fst") |> 
 as_tibble()
```


```{r}
#| fig-height: 10
#| fig-width: 8
#| label: fig-boxplots
#| fig-cap: Análisis de variabilidad, rango y atípicos
#| warning: false
ctl_normalized |> 
 select(-c(avlblty, avlblty_tckt_2hrs)) |> 
 plot_boxplot(
  by = "diag", 
  ncol = 3,
  geom_boxplot_args = list("outlier.color" = "red"), 
  ggtheme = drako, 
  theme_config = list(strip.text = element_text(size = 30)))	
```

Usamos el paquete {bestNormalize} para transformar los datos
y mejorar la visualización de los boxplots. Aunque los gráficos de confianza son
más detallados, los boxplots también muestran variaciones importantes dentro de
cada categoría. El rango intercuartil (IQR) nos indica que hay más variabilidad
en ciertos features. En particular, las variables `corrected_cqi`,
`interferencia` y `time_cl` muestran menos variación. Como se discutió en la
sección @sec-distribuiciones, la variable 64QAM sigue una distribución cercana a
la normal.  Para tratar los valores atípicos podemos considerar el aplicar una
transformación llamada *spatial sign* [ver @kuhn_feature_2020] y
[@kuhn_applied_2013] o bien usar modelos robustos a valores atípicos.

### Dependiente vs categóricas


```{r}
# Seleccionar predictores de tipo factor y dejar top-10 para ciudad
ctl_fc <- ctl_train |> 
 select(where(is.character), -bts_sh_nm, time_cl) |> 
 mutate(ciudad = fct_lump(cty_nm, n = 10, other_level = "OTRO")) |> 
 select(-cty_nm) |> 
 drop_na()
```

```{r}
# Calcular combinaciones para tree-maps
nx <- length(names(ctl_fc |> select(-time_cl)))
choose(nx, 2)
```

```{r}
# Crear combinaciones
comb <- combinations(nx, 2, names(ctl_fc |> select(-time_cl)), repeats = F)
```

```{r}
# Crear objeto con combinaciones
nm <- map2_chr(comb[, 1], comb[, 2], ~ str_c(.x, .y, sep = "_"))
```

```{r}
# Función para dejar únicamente las combinaciones con diagnóstico
tiene_diag <- function(x) str_detect(x, pattern = "diag")
```

```{r}
# Generar mosaicos
lista_mosaicos <- map2(
 .x = comb[, 1],
 .y = comb[, 2], 
 ~ graficar_mosaicos(
  df = ctl_fc,
  f1 = .x,
  f2 = .y,
  ra = 0.3,
  leyenda = TRUE)) |>
 set_names(nm) |> 
 keep_at(tiene_diag)
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-municipio
#| fig-cap: Mayor time-cl por municipio
walk(lista_mosaicos[1], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-departamento
#| fig-cap: Mayor time-cl por departamento
walk(lista_mosaicos[2], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-region
#| fig-cap: Mayor time-cl por región comercial
walk(lista_mosaicos[3], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-region-rf
#| fig-cap: Mayor time-cl por región rf-planning
walk(lista_mosaicos[4], ~ print(.x))
```

### Análisis de correlación

Se debe realizar la inspección de las correlaciones que se encuentren arriba
de 0.75 en valor absoluto.  Este umbral es sugerido por algunos autores
[@kuhn_applied_2013, pag 87].

```{r}
# La correlación de Spearman es más sólida para los valores
# atípicos que la correlación de Pearson.
corm <- ctl_n |>
 correlate(
  use    = "pairwise.complete.obs", 
  method = "spearman", 
  quiet  = TRUE)
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: fig-correlacion
#| fig-cap: Análisis de correlación
corm |> 
 rearrange() |> 
 shave() |> 
 rplot(colours = c("red", "green")) +
 labs(title = "Matriz de correlación", 
      subtitle = "Correlaciones mayores a 0.75") +
 yunkel +
 theme(axis.text.y = element_text(size = 14),
       axis.text.x = element_text(size = 16, angle = 45, hjust = 1))
```

```{r}
matriz_reducida <- corm |> 
 rearrange() |> 
 shave() |> 
 stretch(na.rm = TRUE) |> 
 filter(abs(r) >= .75)
```


```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-altas-correlaciones
#| tbl-cap: "high-r"
matriz_reducida |> 
 arrange(r) |> 
 gt() |> 
 gt_theme_538() |> 
 tab_header(
  title = html("<p style='color:#25a7f0;'><strong>Correlaciones altas</strong></p>"),
    subtitle = md("Mayores a 0.75")
  ) |> 
 data_color(
    columns = r,
    method = "numeric",
    palette = "RdYlGn", 
    reverse = TRUE
  ) |> 
 tab_style(
    style = list(cell_text(align = "center"), v_align = "top"),
    locations = cells_column_labels(columns = everything())
 )
```

La correlación de Pearson es mayor que la de Spearman, lo que podría significar
que existan correlaciones no lineales entre los predictores y la variable
objetivo.  Las interacciones complejas entre predictores es parte de lo
esperado dado el contexto brindado por los SMEs.













































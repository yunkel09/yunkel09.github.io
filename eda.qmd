# EDA {#sec-EDA}

```{r}
#| echo: false
source("_common.R")
source("_functions.R")
source("_load.R")
```

```{r}
#| echo: false
tablero_ctl <- board_folder(path = "tablero_ctl")
```

```{r}
#| echo: false
ctl_split <- pin_read(board = tablero_ctl, name = "ctl_split")
ctl_train <- training(ctl_split)
```

## Estructura

El proceso de preparación y limpieza dió como resultado un único set de datos,
el cual consta de `r nrow(ctl_train)` filas y `r ncol(ctl_train)` columnas.

```{r}
ctl_train |> glimpse(width = 71)
```

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-ctl
#| tbl-cap: "ctl"
ctl_train |> 
 slice_head(n = 5) |> 
 gt() |> 
 tab_header(
    title = md("**Muestra Aleatoria - CTL**"),
    subtitle = md("Tabla principal")
  ) |> 
 gt_theme_538() |> 
 fmt_number(columns = cll_prctg:last_col(), decimals = 2) |> 
 cols_align_decimal() |> 
 cols_align(align = "center", columns = where(~ is.numeric(.x))) |> 
 tab_footnote(
  footnote = md("Cada usuario tiene el top 5 celdas a las que más se conecta"),
  locations = cells_body(columns = bts_sh_nm, rows = 1)) 
```

```{r}
#| code-fold: true
#| fig-align: center
#| code-summary: "Código"
#| label: fig-resumen
#| fig-width: 9
#| fig-cap: Se puede apreciar que la gran mayoría de las columnas están completas. Un 80% son *features* de tipo continuo y el restante son de tipo categórico.  Se requiere explorar los valores faltantes con mayor detalle.
plot_intro(
 ctl_train,ggtheme = yunkel,
 title = "Resumen Descriptivo",
 geom_label_args = list(label.size = 0.8, size = 7),
 theme_config = list(
 axis.text = element_text(size = 40)))
```

## Medidas repetidas {#sec-mr}

```{r}
#| code-fold: true
#| code-summary: "Código"
#| label: tbl-repetidos
#| tbl-cap: "Valores repetidos"
#| column: page
ctl_train |>
 get_dupes(msisdn_dd) |> 
 head(5) |> 
 select(
  fct_srvy_dt, msisdn_dd, bts_sh_nm) |> 
 gt() |> 
 tab_header(
  title = md("**Datos de Perfil**"),
    subtitle = md("Medidas repetidas")
  ) |> 
 gt_theme_538()
```

En la tabla @tbl-repetidos vemos que el identificador único (número de 
celular del usuario) se repite, debido a que contamos con datos de
[perfil](https://bit.ly/3PjtasC)


## Valores faltantes


```{r}
#| fig-align: center
#| label: fig-faltantes
#| fig-cap: La mayor cantidad de valores perdidos se encuentra en la columna `thp_required_lte`. Dependiendo de la distribución de los mismos será posible aplicar técnicas de imputación en la fase de preprocesamiento
#| code-fold: true
#| code-summary: "Código"
#| fig-width: 8
plot_missing(ctl_train, missing_only = TRUE,
 ggtheme = yunkel,
 title = "Valores Faltantes",
 geom_label_args = list(label.size = 0.8, size = 8),
 theme_config = list(
  axis.text = element_text(size = 40)))
```

## Resumen estadístico {#sec-estadisticas}

```{r}
# crear set de datos solo con variables numéricas
ctl_n <- ctl_train |>
 select(where(is.numeric), -msisdn_dd)
```

</br>

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-resumen
#| cap-location: bottom
#| tbl-cap: Resumen estadístico
ctl_n |> 
 resumir() |> 
 gt() |> 
 # tab_header(
 #  title = md("**Resumen Estadístico**"),
 #    subtitle = md("para *features* Numéricos")
 # ) |> 
 gt_theme_538() |> 
 cols_align(align = "center", columns = where(~ is.numeric(.x))) |> 
 fmt_number(columns = where(is.numeric), decimals = 2)
```

En @tbl-resumen se observa que hay valores atípicos en algunas
observaciones.  Los valores mínimos con valor cero para algunas variables
ameritan atención.  La diferencia en la media y la media indica sesgo en la
distribución de los datos generado por los valores atípicos. 

## Análisis univariado

### Variable dependiente

Uno de los primeros pasos del proceso de análisis exploratorios cuando el
propósito final es predecir una respuesta es crear visualizaciones que
ayuden a dilucidar el conocimiento de la respuesta y luego descubrir
relaciones entre los predictores y la respuesta [@kuhn_feature_2020].

```{r}
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-depe
#| fig-cap: Distribución de la variable dependiente
ctl_train |> 
 barra(diag) +
 theme(legend.position = "none") +
 labs(title = "Clasificación variable politómica")
```

Tal como se muestra en la @fig-depe se observa un desbalance en la variable
respuesta.  Este desequilibrio puede ocasionar que el modelo se sesgue hacia
las clases más frecuentes, como "CAPACIDAD" y "PROMOTOR", lo que podría llevar
a un rendimiento deficiente en la clasificación de otras clases.  La aplicación
de técnicas de remuestreo para balancear las clases será clave en la fase de
preprocesamiento.

### Variables numéricas {#sec-distribuiciones}

Analizar la distribución de cada predictor nos puede orientar sobre si
necesitamos hacer ingeniería de características mediante transformaciones antes
del análisis. [@kuhn_feature_2020]

```{r}
dob <- ctl_n |> 
 drop_na()
```

```{r}
# parámetros para graficar distribuciones
pal <- allcolors[1:ncol(dob)]
ndv <- names(dob)
nar <- str_to_title(ndv)
```

```{r}
# crear distribuciones
dist_predictores <- list(ndv, pal, nar) |>
  pmap(~ estimar_densidad(df = dob, d = ..1, color = ..2, titulo = ..1))
```

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| fig-height: 6
#| fig-width: 8
dist_predictores[1:2] |>
 reduce(.f = `+`) +
 plot_layout(ncol = 2) +
 plot_annotation(title    = "Distribución predictores numéricos")
```

- **thp_required_lte:** Se observa en la distribución es plausible.  Se espera
que la mayoría de los usuarios se mantengan un mayor porcentaje de tiempo con
el *throughput* requerido. Sin embargo, el sesgo negativo de esta distribución
podría tener un impacto en el rendimiento del modelo. 

- **cll_prctg:** El sesgo positivo es consistente con una distribución
exponencial, la cual es comúnmente utilizada para modelar el tiempo entre
eventos en un proceso de Poisson, como en este caso.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[3:4] |>
 reduce(.f = `+`)
```

- **rate_prb_dl:** Sabemos que una alta utilización del PRBs podría indicar
una alta demanda de recursos y potencialmente llevar a una degradación del
rendimiento de la red. El comportamiento bimodal podría ser un indicio de que
hay partes de la red que tienen una utilización de recursos muy baja, es decir,
debido a sub-utilización.  El comportamiento bimodal es correcto posterior a la
entrevista con los SMEs.

- **rrc_success_rate:** En la distribución vemos que la gran mayoría de usuarios
presentan una alta tasa de éxito en cuanto a las conexiones RRC (Radio
Resource Control) entre su dispositivo móvil y la red. 


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[5:6] |>
 reduce(.f = `+`)
```

- **erab_success_rate:** Mide la tasa de éxito en la configuración,
modificación y liberación de los portadores de servicio de acceso
radioeléctrico (E-RAB) en una red LTE. Básicamente, muestra qué tan bien la red
está asignando recursos a los usuarios para establecer conexiones de datos y
voz. La distribución es la esperada con un sesgo positivo muy pronunciado, lo
cual es un indicador de que la mayor parte del tiempo este indicador se
encuentra en un rango saludable.

- **service_drop_rate:** Es el porcentaje de caídas o pérdidas en el servicio
de comunicación, específicamente en los recursos de portadora evolucionados
(ERAB, por sus siglas en inglés Evolved Radio Access Bearer). Estas pérdidas
pueden ocurrir por diversas razones como interferencia, baja señal, o problemas
en el backhaul, entre otros. Esta métrica es crucial para evaluar la
optimización de la red. Un alto "Service Drop Rate" puede indicar problemas que
necesitan ser resueltos para mejorar la experiencia del usuario. Si hay un
aumento súbito o si la métrica se mantiene por encima del 1%, se considera un
problema que requiere atención.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[7:8] |>
 reduce(.f = `+`)
```

- **l_ul_interferance_avg:** Representa la interferencia promedio en el enlace
ascendente (UL) de una celda LTE. Se mide en decibelios-milivatios (dBm) y
sirve para evaluar el nivel de ruido o interferencia que podría estar afectando
la calidad del enlace ascendente. Altos niveles de interferencia pueden llevar
a una degradación de la calidad de la llamada, reducir el rendimiento del
enlace de datos y afectar negativamente la experiencia general del usuario. Un
número menor (más negativo) generalmente indica menos interferencia, lo cual es
positivo para el rendimiento de la red. Se aprecia un comportamiento bimodal lo
que podría ser un indicio de celdas problemas muy serios o que están
desconfiguradas. Se debe investigar si es un error en los datos o si son casos
particulares.  Los valores atípicos pueden afectar más la transmisión en los
escenarios donde esta última va por microondas.

- **throughput_dl:** Mide la velocidad de descarga por Unidad de Equipo de 
Usuario en una red celular, generalmente en Mbps. Según la gráfica, el downlink
se ubica en su mayoría arriba de los 25Mbps, lo cual es esperado.  Lo que es
necesario analizar es el throughput_dl menor a 2.7 Mbps. Una gran parte de
los usuarios se encuentran por debajo de este umbral.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[9:10] |>
 reduce(.f = `+`)
```

- **throughput_ul:** Mide la velocidad de transmisión de datos del dispositivo
móvil a la estación base, generalmente también en Mbps. Es normal observar
valores más bajos en el *uplink* que en el *downlink*. El sesgo positivo
también es adecuado.

- **corrected_cqi:** Evalúa la calidad de una celda en una red móvil. Este
índice toma en cuenta varios factores como la potencia de la señal, el nivel de
interferencia y otros parámetros clave para dar un indicador comprensivo de
cómo está funcionando una celda en particular. Aunque los detalles pueden
variar según el fabricante y la implementación, en esencia, mide qué tan bien
una celda puede manejar el tráfico y proporcionar un servicio de alta calidad a
los usuarios. Como política, el departamento de QA definió un umbral crítico de
7, significando que todo lo que esté por debajo de dicho umbral es malo. Debido
a la naturaleza discreta de la distribución de estos valores, observamos que la
superposición de densidad aparenta multimodalidad, sin embargo,
no es así.  Las celdas con valores atípicos inferiores a 1 es porque se
encuentran en tunning, normalmente porque empiezan con número o porque aun no
le han cambiado la etiqueta.

```{r}
#| echo: false
data_ta <- data.frame(
 Index = 0:11,
 Distancia = c(
 "0-156", "156-234", "234-546", "546-1,014", "1,014-1950", "1,950-3510",
 "3,510-6,630", "6,630-14,430", "14,430-30,030", "30,030-53,430", "53,430-76,830",
 ">76,830")
)
```

```{r}
#| echo: false
data_ta |>
 gt() |> 
 tab_header(
   title = md("**Timing Advance**"),
   subtitle = md("Rangos de distancias para LTE en metros")
 ) |> 
 gt_theme_538() |> 
 cols_align(align = "center", columns = where(~ is.numeric(.x)))

```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[11:12] |>
 reduce(.f = `+`)
```

- **ra_ta_ue_index1:** Es una métrica que, en función de distintos índices,
indica tanto la distancia aproximada entre la estación base y el dispositivo
móvil, como la cantidad de conexiones realizadas a esas distancias específicas.
Se utiliza para evaluar y optimizar la cobertura y la capacidad de la red. El
sesgo positivo en este tipo de métrica es esperado en vista de que depende de
la cantidad de muestras de dicha celda.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[13:14] |>
 reduce(.f = `+`)
```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[15:16] |>
 reduce(.f = `+`)
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[17:18] |>
 reduce(.f = `+`)
```

- **ra_ta_ue_total:** Cantidad total de conexiones de datos o llamadas. Pueden
ser del mismo terminal. Pocas celdas tendran muestras muy elevadas.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[19:20] |>
 reduce(.f = `+`)
```

- **volte_erlang:** Mide el volumen de tráfico VoLTE (Voice over LTE) en la
red. Se expresa en "erlangs", que es una unidad de medida de carga de tráfico
telefónico. Si cualquier otra banda supera 1/3 del tráfico VoLTE de la banda
850, se considera una situación crítica. Es necesario tener visibilidad del
tráfico VoLTE en todas las bandas utilizadas para VoLTE, no solo la 850.

- **modulation_64qam_ratio:** Se define como el porcentaje de tiempo en que la
transferencia de datos usa 64QAM, que es una modulación de alta eficiencia.
Esta modulación permite transmitir más bits de información y usa menos bits
para la corrección de errores, lo que la hace más eficiente pero también más
susceptible a problemas de calidad de señal. Como se aprecia en el histograma,
hay un comportamiento bimodal que puede indicar que en ciertas celadas o bien
ubicaciones geográficas, hay pocos usuarios utilizando este tipo de modulación
de mayor capacidad.  Dejando de lado el valor atípico, se observa que la
distribución es bastante normal.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[21:22] |>
 reduce(.f = `+`)
```

- **modulation_16qam_ratio:** Representa el porcentaje de tiempo que la red
está utilizando la modulación 16-Quadrature Amplitude Modulation (16QAM) para
la transferencia de datos. Esta modulación es intermedia en términos de
eficiencia y robustez, permitiendo un balance entre la cantidad de datos
transmitidos y la corrección de errores. Es menos eficiente que 64QAM pero más
robusta contra errores y condiciones de señal no ideales.  La distribución
parece normal y se observa, al igual que con 64QAM, un comportamiento bimodal
que podría ser indicativo de que hay presente otra población en este tipo de
modulación.

- **modulation_qpsk_ratio:** Representa el porcentaje de tiempo en que la red
utiliza la modulación Quadrature Phase Shift Keying (QPSK) para la
transferencia de datos. QPSK es una forma de modulación que es más robusta en
ambientes con condiciones de señal no ideales, como ruido o interferencias. Sin
embargo, es menos eficiente para la transmisión de datos en comparación con
16QAM o 64QAM. A diferencia de los otros dos tipos de modulación, la
distribución de esta modulación es positiva, similar a una distribución
exponencial.  Podría hacer sentido si el objetivo del departamento de QA es
utilizar este tipo de modulación como último recurso en caso de que no se
tengan las condiciones adecuadas en términos de interferencia o cobertura.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[23:24] |>
 reduce(.f = `+`)
```

- **time_cl:** Es una medida fabricada que toma en cuenta la utilización de
PRBs, el CQI, y la velocidad target de la celda, para determinar el grado de
cumplimiento de esa velocidad. Porcentaje de tiempo en buen cell_load, va tanto
3G como LTE. El sesgo negativo es correcto en vista de que se espera que la
mayor parte de las conexiones se encuentren con un buen `cell_load`.

- **time_lte:** Porcentaje de tiempo que permanece conectado a la tecnología
LTE. Entre más tiempo permanece un usuario conectado a la red LTE, podemos
decir que es bueno.  Abajo del 80% podría indicar que las celdas tienen un alto
cell_load lo que indicaría que el terminal hizo el cambio automático a 3G.
Navegar en 3G por lo general se traduce en una experiencia más pobre.  El sesgo
de la distribución es plausible.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[25:26] |>
 reduce(.f = `+`)
```

- **avlblty:** Porcentaje de tiempo de navegación sin falla. Esto aplica por
usuario y representa un medida de que tanto un usuario navegó la cantidad de Mb
esperados con base a su mediana de consumo. La distribución con sesgo negativo
es consistente con la definición de la métrica.

-**avlblty_tckt_2hrs:** Son métricas complementarias a
la de disponibilidad y representan partes de la disponibilidad. Su sesgo es
opuesto.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
dist_predictores[27:28] |>
 reduce(.f = `+`)
```


Como se señaló en la sección @sec-mr, los datos de perfil demandan un
preprocesamiento especializado. Los modelos seleccionados deben ser robustos
ante este tipo de datos y la presencia de valores atípicos. Por esta razón, es
recomendable considerar modelos basados en árboles, que son inherentemente más
tolerantes a estas características. Además, se explorarán diversas
transformaciones de las variables para evaluar y comparar su impacto en el
rendimiento del modelo.


### Variables categóricas

```{r}
ctl_c <- ctl_train |>
 select(where(is.character), -diag) 
```


```{r}
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-cardinalidad
#| fig-cap: Análisis de cardinalidad de variables categóricas
ctl_c |>
 inspect_cat() |> 
 show_plot(high_cardinality = 4, col_palette = 1)
```

```{r}
#| dev: "png"
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-var-categoricas
#| fig-cap: Conteo de variables categóricas
plot_bar(
 data    = ctl_c, 
 ggtheme = yunkel, 
 theme_config = list(strip.text = element_text(size = 22))) |> 
 suppressMessages()
```

```{r}
#| dev: "png"
#| fig-width: 8
#| code-fold: true
#| code-summary: "Código"
#| label: fig-celdas-recurrentes
#| fig-cap: Top de celdas recurrentes por usuarios
ctl_c |> 
 select(bts_sh_nm) |> 
 mutate(celda = fct_lump(bts_sh_nm, n = 10, other_level = "OTRAS")) |> 
 count(celda, sort = TRUE) |> 
 filter(celda != "OTRAS") |> 
 mutate(celda = fct_reorder(celda, n, .desc = FALSE)) |> 
 ggplot(aes(y = celda, x = n)) +
 geom_col() +
 labs(title = "Top celdas más concurridas")
```

## Análisis bivariado

Aunque los boxplots ofrecen una visión más completa de la distribución de los
datos, no proporcionan el mismo nivel de detalle sobre la incertidumbre en torno
a la media que los gráficos de confianza o el MI. Usar tanto MI, como gráficos
de confianza y boxplot, proporcionará una visión más completa de los datos. Los
gráficos de confianza dan detalles sobre la media y su incertidumbre, mientras
que los boxplots muestran la distribución completa.

### Mutual information

La Información Mutua es una métrica de utilidad de características que va más
allá de las correlaciones convencionales de Pearson y Spearman. Mientras que
estas últimas son excelentes para detectar relaciones lineales o monótonas,
tienen sus limitaciones. Por ejemplo, no pueden capturar relaciones más
complejas o no lineales entre variables. Además, las correlaciones tradicionales
suelen centrarse en variables numéricas, dejando de lado las categóricas.

En contraste, la Información Mutua es una herramienta poderosa que puede
capturar cualquier tipo de relación entre variables, ya sean numéricas o
categóricas. Funciona evaluando cómo el conocimiento de una característica
reduce la incertidumbre sobre la variable objetivo. En otras palabras, si
conoces el valor de una característica, ¿cuánto más seguro te sentirías sobre el
valor de la variable objetivo? Esta capacidad la convierte en una métrica
invaluable, especialmente en las etapas iniciales del desarrollo de
características, donde aún no sabemos qué modelo vamos a utilizar.

Es importante tener en cuenta que la Información Mutua es una métrica
univariada, lo que significa que evalúa cada característica de forma individual
en relación con la variable objetivo. No puede detectar interacciones entre
características, pero sigue siendo una herramienta extremadamente útil para una
primera ronda de selección de características.

```{r}
ctl_expanded <- ctl_train |>
 mutate(fecha_15dias = fct_srvy_dt - days(15)) |> 
 recipe(diag ~ ., data = _) |> 
 step_timeseries_signature(fecha_15dias) |> 
 ver() |> 
 select(diag, -c(msisdn_dd, fct_srvy_dt, fecha_15dias))
```

```{r}
tic()
mi <- information_gain(diag ~ ., data = ctl_expanded)
toc()
```


### Dependiente vs numéricas

#### Gráficos de confianza

Debido al desbalance de clases presente en la variable respuesta, será
necesario reflejar claramente el grado de incertidumbre que esto ocasiona.  Si
una clase tiene más observaciones que otra entonces la comparación no sería
justa y la variabilidad podría tener que ver con esto más que con la
variabilidad inherente que intentamos capturar. Para hacer esto, primero
recordemos que una estimación de intervalo describe un rango de valores dentro
del cual es posible que esté un parámetro de la población y un intervalo de
confianza es la probabilidad que asociamos con una estimación de intervalo
[@levin_statistics_1998].

En este sentido, los gráficos de confianza son esenciales para entender no solo
la relación de la variable categórica `diag` con las métricas numéricas, sino
también para capturar el grado de incertidumbre asociado con estas
métricas. Estos gráficos nos permiten ir más allá de las simples medias y
observar cómo la variabilidad en los datos afecta nuestras conclusiones.

Los gráficos de confianza nos permiten ver cómo cada métrica, se relaciona
directamente con las categorías de `diag`. Por ejemplo, si observamos que los
intervalos de confianza para `thp_required_lte` son significativamente bajos en
la categoría "CAPACIDAD", podemos inferir con cierto grado de confianza que un
`thp_required_lte` bajo generalmente indica un problema de capacidad.

El intervalo da una idea de dónde podrían caer las verdaderas medias de
`thp_required_lte` para cada categoría si tuvieras acceso a toda la población,
en lugar de solo una muestra.

En el análisis univariado de la sección @sec-distribuiciones, así como en el
resumen estadístico @sec-estadisticas observamos que las distribuciones se
encuentran con mucho sesgo.

En el análisis exploratorio de datos (EDA), la presencia de valores atípicos
puede distorsionar significativamente las interpretaciones y conclusiones. Los
valores atípicos pueden tener un impacto desproporcionado en la media y la
varianza, lo que a su vez afectará las visualizaciones y las medidas de
tendencia central y dispersión. En este contexto, la transformación de variables
se convierte en una herramienta invaluable para mitigar estos efectos y permitir
un análisis más robusto.

El paquete bestNormalize en R [@R-bestNormalize] es especialmente útil para este
propósito. Según su documentación [@bestNormalize2021], el paquete intenta
encontrar la mejor transformación para normalizar una variable numérica. Utiliza
una variedad de transformaciones, como transformación de Box-Cox, transformación
de Yeo-Johnson, transformación de logaritmo, entre otras, y selecciona la que
minimiza algún criterio de ajuste, como el error cuadrático medio (MSE) o el
estadístico de Shapiro-Wilk para la normalidad.

Una de las ventajas de utilizar bestNormalize es que realiza una búsqueda
exhaustiva a través de múltiples métodos y selecciona la transformación más
óptima para cada característica. Esto es especialmente útil cuando se trabaja
con conjuntos de datos con múltiples características que pueden requerir
diferentes tipos de transformaciones.

Al aplicar la transformación más adecuada, las visualizaciones de los datos
transformados ofrecen una representación más precisa de las relaciones
subyacentes entre las variables. Esto es especialmente útil para técnicas que
asumen la normalidad de los datos. Además, al reducir el impacto de los valores
atípicos, las transformaciones permiten que las métricas como la media y la
varianza sean más representativas del conjunto de datos, lo que facilita la
interpretación y el análisis posterior.

En resumen, la transformación de variables utilizando bestNormalize mejora la
calidad del análisis exploratorio al hacer que las visualizaciones y las
métricas sean más robustas y representativas, permitiendo así una mejor
comprensión de la estructura subyacente de los datos.

```{r}
# Función para calcular la media y el intervalo de confianza
mean_ci <- function(df, metrica, conf.level = 0.95) {
 x  <- df[[metrica]][!is.na(df[[metrica]])]
 m  <- mean(x)
 ci <- t.test(x)$conf.int
 data.frame(media = m, lower = ci[1], upper = ci[2])
}
```

```{r}
#| eval: false
ctl_normalizados <- ctl_train |>
 select(diag, where(is.numeric), -msisdn_dd) |> 
 relocate(diag) |> 
 recipe(diag ~ ., data = _) |> 
 step_best_normalize(all_predictors(), -all_nominal()) |> 
 ver()
```


```{r}
#| eval: false
#| echo: false
write_fst(ctl_normalizados, path = "data/ctl_normalizados.fst", compress = 0)
```

```{r}
#| echo: false
ctl_normalizados <- read_fst("data/ctl_normalizados.fst") |> 
 as_tibble()
```

```{r}
# Función para crear un dataframe con los intervalos por cada métrica
calcular_ci <- function(kpi) {
 ctl_normalizados |> 
 group_by(diag) %>%
 do(mean_ci(., kpi)) %>%
 ungroup() %>%
 arrange(media)
}
```

```{r}
# Guardar las métricas que vamos a comparar
nm <- names(ctl_normalizados)[-length(ctl_normalizados)]
```

```{r}
# Crear lista de dataframes con intervalos de confianza
lista_ci <- nm |> 
 map(~ calcular_ci(kpi = .x)) |> 
 set_names(nm)
```

```{r}
# Crear una lista con las gráficas de cada métrica
analisis_bivariado <- lista_ci |> 
 map2(.y = nm, ~ ggplot(.x, aes(x = diag, y = media)) +
 geom_point() +
 geom_errorbar(aes(ymin = lower, ymax = upper), width = .1) +
 theme(axis.text = element_text(size = 8)) +
 xlab("Diagnóstico") +
 labs(title = .y) +
 drako)
```

Aplicar la transformación antes de realizar los gráficos de confianza puede
ser beneficioso por las siguientes razones:

1. **Robustez frente a Atípicos:** Como se mencionó anteriormente, los valores
atípicos pueden tener un impacto significativo en la media. Al transformar los
datos, se reduce la influencia de estos puntos extremos, lo que resulta en
intervalos de confianza más robustos.

2. **Mejora de la Interpretación:** Los datos transformados pueden hacer que las
diferencias o similitudes entre grupos sean más claras y fáciles de interpretar
en los gráficos de confianza.

3. **Normalidad Aproximada:** Muchas técnicas estadísticas, incluida la
estimación de intervalos de confianza, asumen que los datos son aproximadamente
normales. Las transformaciones pueden ayudar a cumplir con este supuesto.

4. **Consistencia en el Análisis:** Si ya se han transformado las variables para
otros aspectos del análisis exploratorio de datos, mantener esa transformación
para los gráficos de confianza asegura que se están evaluando las mismas
distribuciones a lo largo de todo el análisis.

5. **Claridad en la Presentación:** Los gráficos de datos transformados pueden
ser más fáciles de entender y comunicar, especialmente si reducen la asimetría o
la escala de los datos originales.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-thp-required-lte
#| fig-cap: Porcentaje de tiempo que mantiene el throughput requerido en LTE
walk(analisis_bivariado[1], ~ print(.x))
```

Tal como se ilustra en la figura @fig-thp-required-lte el intervalo de confianza
para la categoría "CAPACIDAD" es relativamente pequeño, lo que sugiere que hay
menos incertidumbre en la estimación de la media para esta categoría.  Esto
podría significar que `thp_required_lte` es una predictor fuerte para predecir
la categoría de capacidad. Es decir, este predictor es importante para ayudar
a distinguir la categoría "capacidad" de las demás.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-cll-prctg
#| fig-cap: Porcentaje de tiempo que el usuario estuvo conectado a la celda.
walk(analisis_bivariado[2], ~ print(.x))
```

Los resultados observados en la @fig-cll-prctg son consistentes con las
expectativas.  Vemos que la categoría "PROMOTOR" muestra un alto porcentaje de
tiempo de conexión a la red, lo cual es congruente con la naturaleza de esta
categoría.  Los intervalos altos pueden deberse a una alta variabilidad en los
datos.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-rate-prb-dl
#| fig-cap: Porcentaje de bloques físicos utilizados para transmitir datos desde la RBS hacia los terminales. Una alta tasa de utilización de PRB podría generar problemas de capacidad.
walk(analisis_bivariado[3], ~ print(.x))
```

Esta métrica es utilizada principalmente por el equipo CTL para determinar
problemas de capacidad en la red LTE.  Vemos en la @fig-rate-prb-dl que hay una
diferencia grande entre esta medición y el resto de categorías, es decir,
niveles altos de `rate-prb-dl` se asocian con problemas de capacidad en la
celda.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-rrc-success-rate
#| fig-cap: Eficiencia en el establecimiento de una conexión RRC
walk(analisis_bivariado[4], ~ print(.x))
```

Dado que `rrc_success_rate` es un indicador de rendimiento que mide la
eficiencia en el establecimiento de una conexión RRC, es lógico pensar que
podría ser más relevante para categorías como "optimización". Sin embargo, si en
la gráfica aparece más cercano a "capacidad" y "cobertura". Podría haber varias
razones para ello.

Una posibilidad es que esta métrica esté interactuando con otra métrica para
proporcionar una mejor separación entre las categorías. En el mundo real, las
métricas raramente operan en aislamiento; a menudo interactúan con otras
variables de formas que pueden ser difíciles de capturar en un análisis
univariado. Por ejemplo, `rrc_success_rate` podría tener un impacto más
significativo en "optimización" cuando se combina con otra variable, como la
calidad de la señal o el ancho de banda disponible.

Si los expertos normalmente usan esta métrica para categorizar "optimización",
pero los datos muestran una relación más fuerte con "capacidad" y "cobertura",
podría ser útil investigar más a fondo.

En resumen, es muy posible que `rrc_success_rate` interactúe con otra métrica
para proporcionar una mejor separación entre las categorías. Este es un buen
ejemplo de por qué a menudo es útil ir más allá del análisis univariado y
considerar interacciones entre variables.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-erab-success-rate
#| fig-cap: Tasa de éxito en la configuración, liberación y modficación de portadoras de servicio de accesso radioeléctrico (E-RAB)
walk(analisis_bivariado[5], ~ print(.x))
```

Al igual que con la métrica anterior, esta métrica puede generar varias
etiquetas si se combina con otras.  De manera aislada y directa parece estar
más relacionada a problemas con cobertura.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-service-drop-rate
#| fig-cap: Pérdida de comunicación
walk(analisis_bivariado[6], ~ print(.x))
```

En la gráfica @fig-service-drop-rate se esperaría que la clase de optimización
estuviera más separada del resto de categorías, sin embargo no es así, lo
que podría indicar que esta métrica podría estar interactuando con otra métrica
para proporcionar una mejor separación entre las categorías.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-interference
#| fig-cap: Interferencia
walk(analisis_bivariado[7], ~ print(.x))
```

En la @fig-interference se aprecia que valores mayores de interferencia podrían
ocasionar problemas de cobertura.  Esta métrica en particular puede
interactuar con muchas otras métricas para determinar otro tipos de problemas
en la red como por ejemplo optimización.

```{r, anova-una-via}
#| echo: false
#| eval: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-dl-anova
#| fig-cap: ANOVA entre-sujetos
bx(.df = ctl_train, .x = diag, .y = thoughput_dl)
```

<!-- En la parte superior de la @fig-throuput-dl-anova vemos el resultado de la -->
<!-- prueba estadística de Fisher.  El p-valor indica que si hay diferencias -->
<!-- significativas con un tamaño de efecto de $\widehat{\omega_{p}^{2}} = 0.09$. -->
<!-- Este tamaño de efecto se puede medir como 9% lo cual es bajo. Se ve en las -->
<!-- comparaciones por pares que capacidad y cobertura presentan diferencias -->
<!-- estadísticamente significativas. -->

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-dl
#| fig-cap: Velocidad de transmisión de datos del dispositivo móvil a la estación base, generalmente también en Mbps.
walk(analisis_bivariado[8], ~ print(.x))
```

CTL describe esta métrica principalmente en términos de capacidad. Aquí la
separación de clases es clara y al parecer la métrica describe muy bien casos
de capacidad.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-throuput-ul
#| fig-cap: Throuput Uplink
walk(analisis_bivariado[9], ~ print(.x))
```

CTL no utiliza esta métrica para realizar la categorización.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-corrected-cqi
#| fig-cap: Índice de calidad general de la celda
walk(analisis_bivariado[10], ~ print(.x))
```

La @fig-corrected-cqi muestra los diferentes índices para cada una de las
categorías. Todo lo que esté por arriba de 7 se considera bueno.  Aunque el 
equipo CTL indica que esta métrica tiene más utilidad para determinar
problemas de optimización, lo que destaca a simple vista es que valores bajos
de esta métrica se asocian más con problemas de capacidad.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-index-1
#| fig-cap: Cantidad de conexiones realizadas a distancias específicas dadas por el índice.
walk(analisis_bivariado[11:17], ~ print(.x))
```


Lo observado es consistente con lo esperado.  En el caso del índice 1, un
porcentaje bajo de conexiones en este índice podría indicar que el resto de
muestras se están obteniendo de índices más lejanos.  Se observa que a partir
del índice 4 el porcentaje empieza a ser diferente entre capacidad y
cobertura. En el índice 5 cobertura y capacidad tienen un porcentaje cercano,
pero siempre cobertura es menor, hasta que finalmente en índice 6 ciertas
conexiones se pueden etiquetar tanto como problemas de capacidad como de
cobertura.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-total-ta
#| fig-cap: Muestras totales de Timing Advance
walk(analisis_bivariado[18], ~ print(.x))
```

Total de muestras en TA


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-volte-erlang
#| fig-cap: Volte Erlang
walk(analisis_bivariado[19], ~ print(.x))
```

Hay una separación más clara para temas de capacidad.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-modulation-qam64
#| fig-cap: Modulación 64QAM
walk(analisis_bivariado[20], ~ print(.x))
```

Hay una separación más clara para temas de capacidad.

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-modulation-qam16
#| fig-cap: Modulación 16QAM
walk(analisis_bivariado[21], ~ print(.x))
```

Hay una separación más clara para temas de capacidad.


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-modulation-qpsk
#| fig-cap: Modulación QPSK
walk(analisis_bivariado[22], ~ print(.x))
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-time-cl
#| fig-cap: Tiempo con buen Cell Load
walk(analisis_bivariado[23], ~ print(.x))
```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-time-lte
#| fig-cap: Tiempo con buen LTE
walk(analisis_bivariado[24], ~ print(.x))
```


```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-avlblty
#| fig-cap: Disponibilidad
walk(analisis_bivariado[25], ~ print(.x))
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-unvlblty-2hrs
#| fig-cap: Disponibilidad cada 2hrs
walk(analisis_bivariado[26], ~ print(.x))
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-unvlblty-prop
#| fig-cap: Proporción de indisponibilidad
walk(analisis_bivariado[27], ~ print(.x))
```

```{r}
#| echo: false
#| fig-height: 6
#| fig-width: 8
#| label: fig-rain
#| fig-cap: Proporción de indisponibilidad
walk(analisis_bivariado[28], ~ print(.x))
```

#### Boxplots

```{r}
ctl_pivoted <- ctl_normalizados |>
 pivot_longer(
  cols      = thp_required_lte:rain,
  names_to  = "metric", 
  values_to = "value") |> 
 filter(!is.na(value))
```

```{r}
ctl_pivoted |>
 ggplot(aes(value, fill = diag)) +
 geom_density(alpha = .5) +
 facet_wrap(~ metric, scales = "free") +
 drako
```




```{r}
#| fig-height: 10
#| fig-width: 8
#| label: fig-boxplots
#| fig-cap: Análisis de variabilidad, rango y atípicos
#| warning: false
ctl_normalized |> 
 select(-c(avlblty, avlblty_tckt_2hrs)) |> 
 plot_boxplot(
  by = "diag", 
  ncol = 3,
  geom_boxplot_args = list("outlier.color" = "red"), 
  ggtheme = drako, 
  theme_config = list(strip.text = element_text(size = 30)))	
```

Usamos el paquete {bestNormalize} para transformar los datos
y mejorar la visualización de los boxplots. Aunque los gráficos de confianza son
más detallados, los boxplots también muestran variaciones importantes dentro de
cada categoría. El rango intercuartil (IQR) nos indica que hay más variabilidad
en ciertos features. En particular, las variables `corrected_cqi`,
`interferencia` y `time_cl` muestran menos variación. Como se discutió en la
sección @sec-distribuiciones, la variable 64QAM sigue una distribución cercana a
la normal.  Para tratar los valores atípicos podemos considerar el aplicar una
transformación llamada *spatial sign* [ver @kuhn_feature_2020] y
[@kuhn_applied_2013] o bien usar modelos robustos a valores atípicos.

### Analizar interacciones

Según los SMEs entrevistados, la categoría **optimización** por lo general
depende de un par de variables, es decir, que esta categoría podría ser el
resultado de interacciones entre variables.  Las métricas que principalmente se
utilizan para determinar esto son:

```{r}
optim_vars <- c(
 "erab_success_rate", 
 "rrc_success_rate", 
 "corrected_cqi", 
 "l_ul_interference_avg")
```


```{r}
ctl_interact <- ctl_train |> 
  select(all_of(optim_vars), diag) |> 
  filter(diag %in% c("OPTIMIZACION", "CAPACIDAD", "COBERTURA")) |> 
  mutate(across(diag, as_factor))
```

```{r}
modelo_multinom <- multinom(
 diag ~ erab_success_rate * rrc_success_rate, data = ctl_interact)
```


```{r}
n1 <-  seq(min(ctl_interact$erab_success_rate), 
           max(ctl_interact$erab_success_rate), 
           length.out = 4) |> round(2)

n2 <- seq(min(ctl_interact$rrc_success_rate), 
                          max(ctl_interact$rrc_success_rate), 
                          length.out = 4) |> round(2)

```


```{r}
# Visualizar las interacciones
efectos_prediccion <- predictorEffects(
 modelo_multinom, ~ erab_success_rate + rrc_success_rate,
 xlevels = list(
   erab_success_rate = n1,
   rrc_success_rate =  n2))
```

```{r}
# Crear gráfico de efectos de predictor
plot(
 efectos_prediccion,
 axes = list(grid = TRUE, x = list(rug = FALSE,
 erab_success_rate = list(ticks = list(at = n1)),
 rrc_success_rate  = list(ticks = list(at = n2))),
                 y = list(style = "stacked")),
 lines = list(col = c("blue", "red", "orange", "brown", "black")),
 lattice = list(key.args = list(columns = 1),
                strip = list(factor.names = FALSE)))
```


### Dependiente vs categóricas

Utilizar ambos indicadores para todas las regiones.
Va a depender si el CVE al que le estamos apuntando es urbano (time_lte) o
rural (time_cl).


```{r}
# Seleccionar predictores de tipo factor y dejar top-10 para ciudad
ctl_fc <- ctl_train |> 
 select(where(is.character), -bts_sh_nm, time_cl) |> 
 mutate(ciudad = fct_lump(cty_nm, n = 10, other_level = "OTRO")) |> 
 select(-cty_nm) |> 
 drop_na()
```

```{r}
# Calcular combinaciones para tree-maps
nx <- length(names(ctl_fc |> select(-time_cl)))
choose(nx, 2)
```

```{r}
# Crear combinaciones
comb <- combinations(nx, 2, names(ctl_fc |> select(-time_cl)), repeats = F)
```

```{r}
# Crear objeto con combinaciones
nm <- map2_chr(comb[, 1], comb[, 2], ~ str_c(.x, .y, sep = "_"))
```

```{r}
# Función para dejar únicamente las combinaciones con diagnóstico
tiene_diag <- function(x) str_detect(x, pattern = "diag")
```

```{r}
# Generar mosaicos
lista_mosaicos <- map2(
 .x = comb[, 1],
 .y = comb[, 2], 
 ~ graficar_mosaicos(
  df = ctl_fc,
  f1 = .x,
  f2 = .y,
  ra = 0.3,
  leyenda = TRUE)) |>
 set_names(nm) |> 
 keep_at(tiene_diag)
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-municipio
#| fig-cap: Mayor time-cl por municipio
walk(lista_mosaicos[1], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-departamento
#| fig-cap: Mayor time-cl por departamento
walk(lista_mosaicos[2], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-region
#| fig-cap: Mayor time-cl por región comercial
walk(lista_mosaicos[3], ~ print(.x))
```

```{r}
#| fig-height: 6
#| fig-width: 8
#| echo: false
#| label: fig-mosaico-region-rf
#| fig-cap: Mayor time-cl por región rf-planning
walk(lista_mosaicos[4], ~ print(.x))
```

### Análisis de correlación

Se debe realizar la inspección de las correlaciones que se encuentren arriba
de 0.75 en valor absoluto.  Este umbral es sugerido por algunos autores
[@kuhn_applied_2013, pag 87].

```{r}
# La correlación de Spearman es más sólida para los valores
# atípicos que la correlación de Pearson.
corm <- ctl_n |>
 correlate(
  use    = "pairwise.complete.obs", 
  method = "spearman", 
  quiet  = TRUE)
```

```{r}
metodos <- c("pearson", "spearman")
```


```{r}
lista_corr <- metodos |> 
 map(~ ctl_n |>
  correlate(
   use    = "pairwise.complete.obs", 
   method = .x, 
   quiet  = TRUE)) |> 
 set_names(metodos)
```


```{r}
#| fig-height: 6
#| fig-width: 8
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: fig-correlacion
#| fig-cap: Análisis de correlación
lista_corr[["spearman"]] |> 
 rearrange() |> 
 shave() |> 
 rplot(colours = c("red", "green")) +
 labs(title = "Matriz de correlación - Spearman", 
      subtitle = "Correlaciones mayores a 0.75") +
 yunkel +
 theme(axis.text.y = element_text(size = 14),
       axis.text.x = element_text(size = 16, angle = 45, hjust = 1))
```

```{r}
matrices_corr <- lista_corr |> 
 map2(.y = metodos, ~ .x |> 
  rearrange() |> 
  shave() |> 
  stretch(remove.dups = TRUE, na.rm = TRUE) |> 
  filter(abs(r) >= .75) |> 
  rename(!!sym(.y) := r)
 )
```


```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-altas-correlaciones-pearson
#| tbl-cap: "high-r"
matrices_corr |> 
 pluck("pearson") |> 
 arrange(pearson) |> 
 gt() |> 
 gt_theme_538() |> 
 tab_header(
  title = html("<p style='color:#25a7f0;'><strong>Correlaciones altas Pearson</strong></p>"),
    subtitle = md("Mayores a 0.75")
  ) |> 
 data_color(
    columns = pearson,
    method = "numeric",
    palette = "RdYlGn", 
    reverse = TRUE
  ) |> 
 tab_style(
    style = list(cell_text(align = "center"), v_align = "top"),
    locations = cells_column_labels(columns = everything())
 )
```

```{r}
#| code-fold: true
#| code-summary: "Mostrar Código"
#| label: tbl-altas-correlaciones-spearman
#| tbl-cap: "high-r"
matrices_corr |> 
 pluck("spearman") |> 
 arrange(spearman) |> 
 gt() |> 
 gt_theme_538() |> 
 tab_header(
  title = html("<p style='color:#25a7f0;'><strong>Correlaciones altas Spearman</strong></p>"),
    subtitle = md("Mayores a 0.75")
  ) |> 
 data_color(
    columns = spearman,
    method = "numeric",
    palette = "RdYlGn", 
    reverse = TRUE
  ) |> 
 tab_style(
    style = list(cell_text(align = "center"), v_align = "top"),
    locations = cells_column_labels(columns = everything())
 )
```

La correlación de Pearson es mayor que la de Spearman, lo que podría significar
que existan correlaciones no lineales entre los predictores y la variable
objetivo.  Las interacciones complejas entre predictores es parte de lo
esperado dado el contexto brindado por los SMEs.








































